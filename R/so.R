#' Read data pasted from R printing into a data frame
#'
#' `read.so` and `read_so` read data copied from R print methods into a
#' data.frame or tibble, respectively.
#'
#' `read.so` is designed to read the print method of a data.frame back into R,
#' provided there are no unquoted spaces within the printing. `read_so` will
#' read the results of printing a data.frame as well, but will return a tibble.
#' Its more significant feature is that it will read in the results of printing
#' a tibble, with or without the "A tibble", type, and additional row and
#' column metadata lines.
#'
#' The `file` parameter will accept a filepath or connection, but given that
#' these functions are built for interactive use, they are built to accept a
#' single string containing the data (distinguished from a filepath by the
#' presence of a newline) or a vector of lines, as may be generated by
#' [clipr::read_clip()].
#'
#' @param file Character. A path to a file, a connection, or literal
#'     data (either a single string or a vector of lines). If unspecified,
#'     reads from the clipboard.
#' @param header Logical. Does the data include a header row?
#' @param na.strings,na Character. Values to convert to `NA`.
#' @param stringsAsFactors Logical. Indicates whether to convert string columns
#'     to factors. Passed along to [read.table()].
#' @param row_names Logical. Indicates whether the input contains a column of
#'     row names. If missing, guesses based on the number of elements in the
#'     header and first row. Row names are removed by `read_so`; to keep them,
#'     use `read.so`. For row names with spaces, try [readr::read_table()]
#'     or [readr::read_fwf()].
#' @param ... Passed along to [read.table()] or [readr::read_table2()] by
#'     `read.so` and `read_so`, respectively. Applied after tibble formatting
#'     lines have been removed.
#'
#' @return For `read.so` a data.frame; for `read_so`, a tibble.
#'
#' @examples
#' lines.df <- capture.output(head(iris))
#' lines_tbl <- capture.output(head(tibble::as_tibble(iris)))
#'
#' read.so(lines.df)
#'
#' read_so(lines.df)
#'
#' \dontrun{
#' # Data has extra metadata lines, so normal reading fails:
#' read.so(lines_tbl)
#'
#' # ...but can work:
#' read.so(lines_tbl, comment = '<', skip = 1)
#' }
#'
#' # Alternately, use the purpose-built function:
#' read_so(lines_tbl)
#'
#' @export
read.so <- function(file = clipr::read_clip(),
                    header = TRUE,
                    na.strings = c("NA", "<NA>"),
                    stringsAsFactors = FALSE,
                    ...){
    if (length(file) > 1) {
        file <- paste(file, collapse = '\n')
    }

    if (grepl('\n', file)) {
        result <- utils::read.table(text = file,
                                    header = header,
                                    na.strings = na.strings,
                                    stringsAsFactors = stringsAsFactors, ...)
    } else {
        result <- utils::read.table(file,
                                    header = header,
                                    na.strings = na.strings,
                                    stringsAsFactors = stringsAsFactors, ...)
    }
    rownames(result) <- utils::type.convert(rownames(result), as.is = TRUE)
    result
}

#' @rdname read.so
#' @export
read_so <- function(file = clipr::read_clip(),
                    row_names,
                    na = c("NA", "<NA>"),
                    ...){
    if (length(file) == 1) {
        lines <- readr::read_lines(file)
    } else {
        lines <- file
    }
    lines <- lines[!grepl('(^\\s*\\*?\\s*(\\S*<\\w+>\\S*\\s*)+$)|(^\\s*\\S*#)', lines)]
    if (missing(row_names)) {
        row_names <- do.call(`!=`, lapply(gregexpr("\\S+", lines[1:2]), length))
    }
    if (row_names) {
        lines[-1] <- gsub('^\\s*\\S+\\s+', '', lines[-1])
    }
    file_text <- paste0(paste(trimws(lines), collapse = '\n'), '\n')
    readr::read_table2(file_text, na = na, ...)
}
